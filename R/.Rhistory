beta <- rgamma(n=1, shape = (10*alpha+c), rate = (sum(theta)+d))
mat[time, ] <- c(theta, beta)
}
write.csv(mat,"matrix.csv", row.names=F)
x <- c(5,1,5,14,3,19,1,1,4,22)
t <- c(34.5,15.7,62.9,126,5.2,31.4,1.05,1.05,2.10,10.50)
alpha <- 1
beta <- 0
c <- 1
d <- 1
theta <- rep(0,10)
mat <- matrix(ncol = 11, nrow = 10000)
mat[1,] <- c(theta, beta)
for (time in c(2:10000)) {
for(i in c(1:10)) {
theta[i] = rgamma(n=1,shape = x[i] + alpha, rate  = t[i] + beta)
}
beta <- rgamma(n=1, shape = (10*alpha+c), rate = (sum(theta)+d))
mat[time, ] <- c(theta, beta)
}
write.csv(mat,"matrix.csv", row.names=F)
head(mat)
plot(mat)
plot(c(1:10000),mat[,1])
plot(1:nrow(mat),mat[,1])
summarize <- function(mat) {
beta <- mat[,11]
mean <- rep(0,11)
median <- rep(0,11)
sd <- rep(0,11)
for(j in c(1:11))
{
mean[j] <- mean(mat[,j])
median[j] <- median(mat[,j])
sd[j] <- sd(mat[,j])
}
summary <- data.frame(mean, sd, median)
summary
}
x <- c(5,1,5,14,3,19,1,1,4,22)
t <- c(34.5,15.7,62.9,126,5.2,31.4,1.05,1.05,2.10,10.50)
alpha <- 1
beta <- 0
c <- 1
d <- 1
theta <- rep(1,10)
mat <- matrix(ncol = 11, nrow = 210000)
mat[1,] <- c(theta, beta)
for (time in c(2:210000)) {
for(i in c(1:10)) {
theta[i] = rgamma(n=1,shape = x[i] + alpha, rate  = t[i] + beta)
}
beta <- rgamma(n=1, shape = (10*alpha+c), rate = (sum(theta)+d))
mat[time, ] <- c(theta, beta)
}
after_burn_mat <- mat[1001:210000,]
summary <- summarize(after_burn_mat)
summary
?rnorm
?dbeta
dbeta(1,1,1)
dbeta(5,1,1)
dbeta(6,1,1)
dbeta(0.1,1,1)
dbeta(0.2,1,1)
dbeta(1.1,1,1)
dbeta(1.1,1,4)
dbeta(0.1,1,4)
dbeta(0.6,1,4)
require(caret)
require(foreign)
require(nnet)
require(ggplot2)
require(reshape2)
require(e1071)
library("neuralnet")
splitdf <- function(dataframe, seed=5) {
if (!is.null(seed)) set.seed(seed)
index <- 1:nrow(dataframe)
trainindex <- sample(index, trunc(length(index)/2))
trainset <- dataframe[trainindex, ]
testset <- dataframe[-trainindex, ]
list(trainset=trainset,testset=testset)
}
train <- read.csv("/Users/ahmademad/Documents/Kaggle/data/train.csv", header=TRUE)
splitdf <- function(dataframe, seed=5) {
if (!is.null(seed)) set.seed(seed)
index <- 1:nrow(dataframe)
trainindex <- sample(index, trunc(length(index)/2))
trainset <- dataframe[trainindex, ]
testset <- dataframe[-trainindex, ]
list(trainset=trainset,testset=testset)
}
train <- read.csv("/Users/ahmademad/Documents/Kaggle/data/train.csv", header=TRUE)
splitted <- splitdf(train)
train <- splitted$trainset
#train <- train[colSums(train)!=0]
test <- splitted$testset
labels <- as.factor(train[,1])
train <- train[,-1]
test_unlabeled <- test[,-1]
test_actuals <- test[,1]
n <- names(data)
f <- paste(n, collapse=' + ')
m <- model.matrix(
~ .,
data = data
)
n <- names(data)
f <- as.formula(paste("labels1+labels2+labels3+labels4+labels5+labels6+
labels7+labels8+labels9 ~", paste(n[!n %in%
c("labels","labels1,labels2,labels3,labels4,labels5,labels6,
labels7, labels8, labels9")]
,collapse = " + ")))
net <- neuralnet(f, data = m, hidden = 15, threshold=0.01)
require(caret)
require(foreign)
require(nnet)
require(ggplot2)
require(reshape2)
require(e1071)
splitdf <- function(dataframe, seed=5) {
if (!is.null(seed)) set.seed(seed)
index <- 1:nrow(dataframe)
trainindex <- sample(index, trunc(length(index)/2))
trainset <- dataframe[trainindex, ]
testset <- dataframe[-trainindex, ]
list(trainset=trainset,testset=testset)
}
train <- read.csv("/Users/ahmademad/Documents/Kaggle/data/train.csv", header=TRUE)
splitted <- splitdf(train)
train <- splitted$trainset
#train <- train[colSums(train)!=0]
test <- splitted$testset
labels <- as.factor(train[,1])
train <- train[,-1]
test_unlabeled <- test[,-1]
test_actuals <- test[,1]
# Model Naive Bayes
system.time(model <- naiveBayes(train,labels))
system.time(predictions <- predict(model, test_unlabeled))
d <- data.frame(test_actuals, predictions)
d["matched"] = d$test_actuals == d$predictions
table(d$matched)
?dgamma
qgamma
qgamma(c(0.1,0.5,1))
qgamma(c(0.1,0.5,1), shape =1)
qgamma(c(1), shape =1)
qgamma(c(0), shape =1)
train <- read.csv('/Users//ahmademad/Google Drive/train.csv', stringsAsFactors = F)
head(train)
View(train)
table(train$City.Group)
table(train$City)
test <- read.csv('/Users//ahmademad/Google Drive/test.csv', stringsAsFactors = F)
names(test)
View(test)
View(train)
summary(train$revenue)
?lm
table(train$P30)
table(train$P27)
table(train$P26)
typeof(train$P26)
?as.factor
train <- read.csv('/Users//ahmademad/Google Drive/train.csv', stringsAsFactors = T)
test <- read.csv('/Users//ahmademad/Google Drive/test.csv', stringsAsFactors = T)
str(train)
mycols <- paste('P',c(1:37))
mycols
mycols <- paste('P',c(1:37), sep='')
mycols
train[,mycols] <- data.frame(apply(train[cols], 2, as.factor))
train[,mycols] <- data.frame(apply(train[mycols], 2, as.factor))
str(train)
?subset
train2 <- subset(train, select = -c(Id,Open.Date))
str(train2)
summary(lm(revenue~., train2))
set.seed(1)
x <- matrix(rnorm(20*2), ncol-2)
x <- matrix(rnorm(20*2), ncol=2)
x
y = c(rep(-1,10), rep(1,10))
x[y==1,] =x[y==1,] + 1
plot(x,col=(3-y))
dat <- data.frame(x=x, y =as.factor(y))
library(e1071)
svmfit <- svm(y~., data=dat, kernel = "linear", cost = 10, scale=F)
plot(svmfit, dat)
summary(svmfit)
?tune
install.packages("RecordLinkage")
require(RecordLinkag)
require(RecordLinkage)
compare.linkage
emWeights
?emWeights
showMethods("Emweights")
showMethods("emWeights")
emWeights
emClassify
compare.linkage
emWeights
t <- data.matrix(cbind(c(1,2,3), c(4,5,6), c(7,8,9)))
t
cov(t)
?cov
t <- data.matrix(cbind(c(1,9,3), c(4,5,6), c(7,8,9)))
cov(t)
t <- data.matrix(cbind(c(1,9,3), c(4,8,6), c(7,19,9)))
cov(t)
?mean
mean(t)
X <- lapply(t, mean)
X
X <- data.matrix(lapply(t, mean))
X
t
?rowMeans
rowMeans(t)
colMeans(t)
var(c(1,2,3))
A[[1]] - means[1]
A = t
A[[1]] - means[1]
means <- colMeans(A)
A[[1]] - means[1]
A[[1]]
A[,1]
A[1,]
A
A[,1] - means[1]
means
cov(A)
?crossprod
crosspod(A)
crossprod(A)
A
1*4 + 9*8 + 3*6
a <- c(1,2,3)
b <- c(4,5,6)
crossprod(a,b)
?cov
means
A - means
A
d <- A - means
E <- crossprod(d)
E
cov(A)
E <- E/nrow(A)
E
means <- colMeans(A)
d <- A - means
E <- crossprod(d)/ (nrow(A)-1)
E
cov(A)
A
d
means
A - t(means)
means
A - data.matrix(means)
data.matrix(means)
means
A - means
A
t(A) - means
t(A)
A
means
data.matrix(means, means, means)
data.matrix(c(means, means, means))
?data.matrix
data.matrix(means,)
data.matrix(means)
?matrix
matrix(means, ncol=3)
matrix(means, ncol=3, nrow=3)
means <- matrix(means, ncol=nrow(A), nrow=nrow(A))
d <- A - means
d
E <- crossprod(d)/ (nrow(A)-1)
E
cov(A)
A
means
means <- t(matrix(means, ncol=nrow(A), nrow=nrow(A)))
d <- A - means
E <- crossprod(d)/ (nrow(A)-1)
E
cov(A)
install.packages("RCppArmadillo")
install.packages("RcppArmadillo")
require(RcppArmadillo)
code <- 'arma::mat x = Rcpp::as<arma::mat>(X);
arma::mat mu = Rcpp::as<arma::mat>(Mu);
arma::mat sigma = Rcpp::as<arma::mat>(Sigma);
int n = x.n_rows;
arma::vec md(n);
for (int i=0; i<n; i++){
arma::mat x_i = x.row(i) - mu;
arma::mat Y = arma::solve( sigma, arma::trans(x_i) );
md(i) = arma::as_scalar(x_i * Y);
}
return wrap(md);'
mahalanobis_RcppArma <- cxxfunction( signature(X="numeric",
Mu="numeric", Sigma="numeric"), code, plugin="RcppArmadillo")
require(inline)
install.packages("inline")
require(inline)
code <- 'arma::mat x = Rcpp::as<arma::mat>(X);
arma::mat mu = Rcpp::as<arma::mat>(Mu);
arma::mat sigma = Rcpp::as<arma::mat>(Sigma);
int n = x.n_rows;
arma::vec md(n);
for (int i=0; i<n; i++){
arma::mat x_i = x.row(i) - mu;
arma::mat Y = arma::solve( sigma, arma::trans(x_i) );
md(i) = arma::as_scalar(x_i * Y);
}
return wrap(md);'
code
mahalanobis_RcppArma <- cxxfunction( signature(X="numeric",
Mu="numeric", Sigma="numeric"), code, plugin="RcppArmadillo")
require(rcpp)
install.packages("rcpp")
require(Rcpp)
mahalanobis_RcppArma <- cxxfunction( signature(X="numeric",
Mu="numeric", Sigma="numeric"), code, plugin="RcppArmadillo")
mahalanobis_RcppArma <- cxxfunction( signature(X="numeric",
Mu="numeric", Sigma="numeric"), code, plugin="RcppArmadillo")
install.packages("RcppArmadillo")
install.packages("RcppArmadillo")
require(RcppArmadillo)
code <- 'arma::mat x = Rcpp::as<arma::mat>(X);
arma::mat mu = Rcpp::as<arma::mat>(Mu);
arma::mat sigma = Rcpp::as<arma::mat>(Sigma);
int n = x.n_rows;
arma::vec md(n);
for (int i=0; i<n; i++){
arma::mat x_i = x.row(i) - mu;
arma::mat Y = arma::solve( sigma, arma::trans(x_i) );
md(i) = arma::as_scalar(x_i * Y);
}
return wrap(md);'
mahalanobis_RcppArma <- cxxfunction( signature(X="numeric",
Mu="numeric", Sigma="numeric"), code, plugin="RcppArmadillo")
require(inline)
mahalanobis_RcppArma <- cxxfunction( signature(X="numeric",
Mu="numeric", Sigma="numeric"), code, plugin="RcppArmadillo")
t = data.frame(c(42,52,48,58), c(4,5,4,3))
t
corr(t)
cor(t)
cov(t)
covariance(t)
covariance <- function(A) {
means <- colMeans(A)
means <- t(matrix(means, ncol=nrow(A), nrow=nrow(A)))
d <- A - means
E <- crossprod(d)/ (nrow(A)-1)
d[1] <- A[,1] - means[1]
d[2] <- A[,1] - means[1]
d[3] <- A[,1] - means[1]
}
covariance(t)
covariance(data.matrix(t))
covariance(as.data.matrix(t))
rm((list=ls()))
rm(list=ls())
setwd("/Users/ahmademad/Documents/wCorr/R")
require(Rcpp)
require(rbenchmark)
U <- c(72, 88, 112, 93, 86, 87, 78, 69, 101, 108, 104,
92, 77, 80, 99, 92, 72, 81, 88, 104, 103, 85, 96, 96, 104)
M <- c(0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,2,2,2,2,2)
w <- rep(1, length(U))
x <- U
M <- as.numeric(as.factor(M))
uM <- sort(unique(M))
theta0 <- sapply(uM[-length(uM)],function(z) qnorm(mean(M<=z)) )
sourceCpp("helpers.cpp")
sourceCpp("helpers.cpp")
fixxFast(x,w)
sourceCpp("helpers.cpp")
fixxFast(x,w)
sourceCpp("helpers.cpp")
fixxFast(x,w)
??Rf_Print
?Rcpp::`Rcpp-package`
fixx <- function(x,w) {
mux <- sum(x*w)
sdx <- sum(w*(x-mux)^2)
(x-mux)/sqrt(sdx)
}
fixx(x,w)
sourceCpp("helpers.cpp")
fixxFast(x,w)
sourceCpp("helpers.cpp")
fixxFast(x,w)
sourceCpp("helpers.cpp")
fixxFast(x,w)
sourceCpp("helpers.cpp")
fixxFast(x,w)
sourceCpp("helpers.cpp")
fixxFast(x,w)
fixx(x, w)
sourceCpp("helpers.cpp")
benchmark(polys_opt1(U, M, w, FALSE), polys_opt1Fast(U, M, w, FALSE))
polys_opt1 <- function(x, M, w, ML=FALSE) {
polysLnL <- function(x,M,rho,theta,w) {
R <- (1-rho^2)^0.5
Qp2 <- (theta[M+2] - rho*x) / R
Qp1 <- (theta[M+1] - rho*x) / R
#print(M)
#-log(R) + sum(w*dnorm(x,log=TRUE)) + sum(w*log(pnorm(Qp2) - pnorm(Qp1)))
#-log(R) + sum(w*dnorm(x,log=TRUE)) + sum(w*log(Phi(x,M+2,rho,theta) - Phi(x,M+1,rho,theta)))
sum(w*dnorm(x,log=TRUE)) + sum(w* log(pnorm(Qp2) - pnorm(Qp1)))
}
fixx <- function(x,w) {
mux <- sum(x*w)
sdx <- sum(w*(x-mux)^2)
(x-mux)/sqrt(sdx)
}
mapCor <- function(v) {
tanh(v)
}
mapTheta <- function(v) {
vv <- cumsum(c(v[1],exp(v[-1])))
c(NA,-Inf,vv,Inf)
}
optF <- function(x,M,w) {
w <- w/sum(w)
fx <- fixx(x,w)
function(par) {
res <- polysLnL(fx,M,mapCor(par[1]),mapTheta(par[-1]),w)
ifelse(res==-Inf,.Machine$double.xmax,-1*res)
}
}
optFc <- function(x,M,w,theta0) {
w <- w/sum(w)
fx <- fixx(x,w)
ftheta0 <- mapTheta(theta0)
function(par) {
res <- polysLnL(fx,M,mapCor(par[1]),ftheta0,w)
ifelse(res==-Inf,.Machine$double.xmax,-1*res)
}
}
M <- as.numeric(as.factor(M))
uM <- sort(unique(M))
theta0 <- sapply(uM[-length(uM)],function(z) qnorm(mean(M<=z)) )
imapTheta <- function(theta0) {
c(theta0[1], log(theta0[-1]-theta0[-length(theta0)]))
}
imapCor <- function(cor) {
atanh(cor)
}
mapCor <- function(v) {
tanh(v)
}
#bob <- bobyqa(par=c(imapCor(cor(x,M)),imapTheta(theta0)), fn=optF(x,M,w))
if(ML) {
bob <- bobyqa(par=c(imapCor(cor(x,M)),imapTheta(theta0)), fn=optF(x,M,w))
return(  mapCor(bob$par[1]))
} else {
opt <- optimize(optFc(x,M,w,imapTheta(theta0)), imapCor(cor(x,M)) + c(-3,3))
return( mapCor(opt$minimum) )
}
}
polys_opt1Fast <- function(x, M, w, ML=FALSE) {
optF <- function(x,M,w) {
w <- w/sum(w)
fx <- fixxFast(x,w)
function(par) {
res <- polysLnL(fx,M,tanh(par[1]),mapThetaFast(par[-1]),w)
ifelse(res==-Inf,.Machine$double.xmax,-1*res)
}
}
M <- as.numeric(as.factor(M))
uM <- sort(unique(M))
theta0 <- sapply(uM[-length(uM)],function(z) qnorm(mean(M<=z)) )
imapTheta <- function(theta0) {
c(theta0[1], log(theta0[-1]-theta0[-length(theta0)]))
}
#bob <- bobyqa(par=c(imapCor(cor(x,M)),imapTheta(theta0)), fn=optF(x,M,w))
if(ML) {
bob <- bobyqa(par=c(imapCorFast(cor(x,M)),imapTheta(theta0)), fn=optF(x,M,w))
return(  tanh(bob$par[1]))
} else {
w <- w/sum(w)
fx = fixxFast(x, w);
ftheta0 = mapThetaFast(imapTheta(theta0));
temp1 <- ftheta0[M+2]
temp2 <- ftheta0[M+1]
temp3 <- w*dnorm(x)
opt <- optimize(optFcFast, interval = imapCorFast(cor(x,M)) + c(-3,3), x,w,temp1, temp2, temp3)
return( tanh(opt$minimum) )
}
}
benchmark(polys_opt1(U, M, w, FALSE), polys_opt1Fast(U, M, w, FALSE))
sourceCpp("helpers.cpp")
sourceCpp("helpers.cpp")
benchmark(polys_opt1(U, M, w, FALSE), polys_opt1Fast(U, M, w, FALSE))
Sys.setenv("PKG_CXXFLAGS"="-fopenmp")
Sys.setenv("PKG_LIBS"="-fopenmp")
sourceCpp("helpers.cpp")
sourceCpp("helpers.cpp")
sourceCpp("helpers.cpp")
sourceCpp("helpers.cpp")
